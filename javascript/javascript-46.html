<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      #root {
        width: 100vw;
        height: 100vh;
        background: #333;
      }
      #box {
        width: 100px;
        height: 100px;
        background-color: #ccc;
      }
      .flex-center {
        display: flex;
        justify-content: center;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <div id="root" class="flex-center">
      <div id="box"></div>
    </div>
    <script>
      const dom = {
        root: document.getElementById("root"),
        box: document.getElementById("box"),
      };
      const { box } = dom;
      box.style.position = "absolute";
      box.style.top = "0px";
      box.style.left = "0px";
      const posValue = {
        top: 0,
        left: 0,
      };
      let state = true;
      box.addEventListener("click", () => {
        let moveTop = setInterval(() => {
          console.log("interval start");
          if (state === true) {
            posValue.top++;
            box.style.top = posValue.top + "px";
            if (postValue.top === 500) {
              clearInterval(moveTop);
              state = false;
              posValue.top = 0;
              box.style.top = posValue.top + "px";
            } else {
              state = true;
            }
          }
        }, 16);
      });
    </script>
  </body>
</html>

<!-- 웹모션 전문개발자, 프로모션페이지 인터렉션을 담당하는 전문 개발자들은 주목도가 매우 높은 애니메이션 처리에 상당한 노력을 기울이고 있습니다. 프론트엔드에서 무언가 표현하고 연출할 때 거의 강제되다시피 사용하게 되는 두개의 함수,

setTimeout()
setInterval()

비동기 처리 메서드(본래의 작성은 BOM, window.setInterval(), node.js, global.setInterval() 이므로, 일반함수가 아닌 메서드가 옳습니다.)가 주요 핵심 개념이 됩니다. 문제는 '정해진 시간'에 작동하는 원리를 두고 있는데, '시간' 이란 개념과 함수 호출 스택과의 상성 혹은 조화가 이루어지지 않기 때문에 메커니즘 상으로 자바스크립트 엔진은 두개의 실행 환경으로 분리하고 있습니다. 

자동차에 연료를 넣고 주행을 하면, 하나는 동력으로 다른하나는 배기가스로 만들어지는 것과 비슷한 개념입니다. 무언가 다른 동작을 진행한다는 것이 핵심인데, 이것이 눈에 보이지 않기 때문에 개발자입장에서는 관점충돌이 일어나는 점이 주요 훈련 초점이 되겠습니다. 

무슨 순서를 준수하여 진행하고 싶은데 무언가 코드상으로는 문제가 없지만 에러가나는 대표적인 사례가 바로 비동기개념에 대한 논지 때문입니다. (에러가 안나는데 동작이 원하는데로 안되는 것은 매우 경계해야 되기 때문)

비동기처리의 개념은 애니메이션과 같은 표현용도보다 훨씬 큰, '네트워크'에서 그 진가를 발휘합니다. 사용자경험, 처리우선, 실행우선, 순서우선 모두 비동기처리 개념 하위에 있기 때문에 '원하는 때에 원하는 만큼 실행' 시키는 것이 비동기처리 개념이해 수준과 거의 맞물린다고 봐도 무방할 정도로 중요합니다.

신입 개발자들이 가장 애먹는 처리가 바로 비동기처리이니, 도전의식을 가지고 하나씩 순차적으로 이해한다면 어느세 자신이 다룰 수 있는 강력한 무기가 되어 줄 것입니다. 이에 다음과 같은 훈련 방식을 제안합니다.

1. 콜백함수로 비동기함수를 동기처리 해보기 (아래의 예제와 같은)
2. 콜백함수가 왜 피곤한지 정리하기 -> 실무에 나가서도 다시보게 되는 개념이니 꼭 챙겨두시기 바랍니다.
3. 자바스크립트는 콜백함수의 중첩을 어떻게 해결하고자 했는지 확인하기 (Promise)
4. Promise를 통해 본 예제와 같은 사례의 제어를 '원하는 만큼' 충분하게 응용해보기
5. Promise 자체의 태생적인 단점을 찾아보기

여기서 순서를 건너띄고 promise를 외우듯 두어번 써보는 것으로 비동기처리를 이해하기가 매우 어렵기 때문에, 개인훈련차원에서 반복적인 연습이 반드시 필요합니다. 네트워크와 서버는 거의 대부분 비동기로 처리되기 때문에 에러의 원인을 찾는 중요한 개념이 됩니다. -->
